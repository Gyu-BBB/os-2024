# 스케줄링: 비례 공유(Proportional Share)

이번 강의에서는 운영체제의 중요한 개념 중 하나인 비례 공유 스케줄링(Proportional Share Scheduling)에 대해 알아보도록 하겠습니다. 비례 공유 스케줄러는 각 작업이 CPU 시간의 특정 비율을 보장받을 수 있도록 하는 것을 목표로 합니다. 이를 통해 시스템 자원의 공정한 분배를 실현할 수 있습니다.

먼저, 비례 공유 스케줄링의 기본 개념인 티켓(Ticket)에 대해 설명드리겠습니다. 티켓은 프로세스가 받아야 할 자원의 몫을 나타내는 개념으로, 전체 티켓 수에서 각 프로세스가 가진 티켓의 비율이 해당 프로세스의 자원 점유율을 결정합니다.

다음으로, 대표적인 비례 공유 스케줄링 알고리즘인 로터리 스케줄링(Lottery Scheduling)과 스트라이드 스케줄링(Stride Scheduling)에 대해 알아보겠습니다. 로터리 스케줄링은 무작위로 당첨 티켓을 선택하여 해당 프로세스를 실행하는 방식이며, 스트라이드 스케줄링은 각 프로세스의 티켓 수에 따라 스트라이드(Stride) 값을 계산하고, 이를 기반으로 프로세스를 선택하는 결정론적인 방법입니다.

이어서, 리눅스에서 사용되는 CPU 스케줄러인 완전 공정 스케줄링(Completely Fair Scheduling, CFS)에 대해 자세히 살펴보겠습니다. CFS는 가상 실행 시간(vruntime)이라는 개념을 도입하여 프로세스 간의 공정성을 유지하며, 레드-블랙 트리(Red-Black Tree)를 사용하여 효율적으로 프로세스를 관리합니다.

마지막으로, CFS에서 프로세스의 우선순위를 제어하는 nice 값과 가중치(Weight) 개념, 그리고 I/O와 슬립 상태의 프로세스를 처리하는 방법에 대해 알아보겠습니다.

이번 강의를 통해 여러분은 비례 공유 스케줄링의 기본 개념과 알고리즘, 그리고 리눅스의 CFS 스케줄러에 대해 깊이 있게 이해할 수 있을 것입니다. 실제 운영체제에서 사용되는 스케줄링 기법을 학습함으로써, 시스템 자원 관리에 대한 통찰력을 얻을 수 있을 것으로 기대합니다.

## 비례 공유 스케줄러

비례 공유 스케줄러는 공정한 분배를 목표로 하는 스케줄러입니다. 각 작업이 CPU 시간의 특정 비율을 보장받도록 합니다. 반환 시간이나 응답 시간에 최적화되어 있지는 않습니다.

## 기본 개념

티켓(Ticket)은 프로세스가 받아야 할 자원의 몫을 나타냅니다. 티켓의 비율은 해당 시스템 자원에 대한 프로세스의 점유율을 의미합니다.

예를 들어, 프로세스 A와 B가 있고, A는 75개의 티켓을, B는 25개의 티켓을 가지고 있다면, A는 CPU의 75%, B는 CPU의 25%를 점유하게 됩니다.

## 로터리 스케줄링(Lottery Scheduling)

로터리 스케줄링에서는 스케줄러가 당첨 티켓을 선택하고, 해당 프로세스의 상태를 로드하여 실행합니다.

예를 들어, 총 100개의 티켓이 있고, 프로세스 A가 0~74번, 프로세스 B가 75~99번의 티켓을 가지고 있다고 가정해 봅시다.

## 티켓 메커니즘

1. 티켓 통화(Ticket Currency): 사용자는 자신의 작업 간에 원하는 대로 티켓을 할당할 수 있습니다. 시스템은 이를 정확한 전역 값으로 변환합니다.

2. 티켓 전송(Ticket Transfer): 프로세스는 자신의 티켓을 일시적으로 다른 프로세스에게 넘겨줄 수 있습니다.

3. 티켓 인플레이션(Ticket Inflation): 프로세스는 자신이 소유한 티켓의 수를 일시적으로 늘리거나 줄일 수 있습니다. CPU 시간이 더 필요한 프로세스는 티켓을 늘릴 수 있습니다.

## 구현

프로세스를 티켓 크기에 따라 정렬된 리스트로 유지합니다. 티켓이 가장 많은 프로세스가 먼저 옵니다.

불공정성 지표(Unfairness Metric, U)는 첫 번째 작업이 완료된 시간을 두 번째 작업이 완료된 시간으로 나눈 값입니다. U 값이 1에 가까울수록 두 작업이 거의 동시에 완료되었음을 의미합니다.

## 결정론적 접근법: 스트라이드 스케줄링(Stride Scheduling)

각 프로세스의 스트라이드(Stride)는 (큰 수) / (프로세스의 티켓 수)로 계산됩니다.

프로세스가 실행될 때마다 해당 프로세스의 카운터(패스 값)를 스트라이드만큼 증가시킵니다. 패스 값이 가장 낮은 프로세스를 선택하여 실행합니다.

## 리눅스의 완전 공정 스케줄링(Completely Fair Scheduling, CFS)

CFS는 현재 리눅스에서 사용되는 CPU 스케줄러입니다. 고정된 시간 조각을 사용하지 않고, 프로세스에게 프로세서의 비례적인 시간 조각을 할당합니다.

nice 값을 사용하여 우선순위를 제어할 수 있으며, 프로세스를 효율적으로 검색, 삽입 및 삭제하기 위해 레드-블랙 트리(Red-Black Tree)를 사용합니다.

## CFS의 기본 개념

1. 가상 실행 시간(Virtual Runtime, vruntime): 프로세스가 실행된 시간을 나타내는 프로세스별 변수입니다. 실제 실행 시간에 비례하여 증가합니다. CFS는 vruntime이 가장 낮은 프로세스를 다음에 실행합니다.

2. sched_latency: 일반적으로 48ms로 설정되며, 프로세스의 시간 조각은 sched_latency / (프로세스 수)로 계산됩니다.

3. min_granularity: 최소 시간 조각(일반적으로 6ms)으로, 프로세스가 너무 많을 때 스케줄링 오버헤드에 많은 시간이 소요되지 않도록 합니다.

## 가중치(Weight)

CFS는 nice 값을 사용하여 프로세스 우선순위를 제어합니다. nice 값은 -20부터 +19까지의 정수 값으로 설정할 수 있으며, 가중치(weight)로 매핑됩니다.

새로운 시간 조각 공식:

$timeslice_k = \frac{weight_k}{\sum_{i=0}^{n-1} weight_i} \cdot sched\_latency$

가중치를 고려한 vruntime 공식:

$vruntime_i = vruntime_i + \frac{weight_0}{weight_i} \cdot runtime_i$

## 레드-블랙 트리(Red-Black Tree)

CFS는 준비 큐(Ready Queue)의 구조로 레드-블랙 트리를 사용합니다. 레드-블랙 트리는 균형 잡힌 이진 트리로, 최악의 경우에도 삽입을 처리할 수 있습니다.

레드-블랙 트리의 순서는 O(log n)이며, 가상 실행 시간이 최소인 프로세스를 효율적으로 찾을 수 있습니다. 실행 중이거나 실행 가능한 프로세스만 트리에 유지됩니다.

## I/O와 슬립 프로세스 처리

프로세스가 슬립 상태에서 깨어난 후 vruntime이 매우 작아져서 일부 프로세스가 CPU를 독점하는 상황을 방지하기 위해, 프로세스가 깨어날 때 해당 프로세스의 vruntime을 트리에서 찾은 최소값으로 설정합니다.

그러나 이로 인해 짧은 시간 동안 자주 슬립하는 프로세스는 CPU를 공정하게 점유하지 못할 수 있습니다.
