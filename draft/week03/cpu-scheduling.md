# 스케줄링: 소개

운영체제의 핵심 구성 요소 중 하나인 스케줄러에 대해 알아보겠습니다. 스케줄러는 여러 프로세스가 CPU를 사용할 수 있도록 조정하는 역할을 합니다. 이 강의에서는 다양한 스케줄링 알고리즘과 그 특성을 살펴볼 것입니다.

우선, 스케줄링 알고리즘을 비교하기 위한 작업 부하 가정과 성능 메트릭에 대해 설명하겠습니다. 그런 다음, 선입 선처리(FIFO), 최단 작업 우선(SJF), 최단 완료 시간 우선(STCF), 라운드 로빈(RR) 등의 대표적인 스케줄링 알고리즘을 자세히 다루어 보겠습니다. 각 알고리즘의 동작 원리와 장단점을 예시와 함께 이해할 수 있을 것입니다.

마지막으로, I/O를 고려한 스케줄링 상황도 알아보겠습니다. 프로세스가 I/O 작업을 수행할 때 스케줄러가 어떻게 대응해야 하는지 살펴볼 것입니다.

이 강의를 통해 여러분은 운영체제의 스케줄링 메커니즘에 대한 전반적인 이해를 얻을 수 있을 것입니다. 다양한 스케줄링 알고리즘의 특성을 파악하고, 상황에 따라 적절한 알고리즘을 선택할 수 있는 기초를 다질 수 있기를 바랍니다.

## 작업 부하 가정

- 모든 작업은 동일한 시간 동안 실행됩니다.
- 모든 작업은 동시에 도착합니다.
- 모든 작업은 CPU만 사용하며, I/O는 수행하지 않습니다.
- 각 작업의 실행 시간은 알려져 있습니다.

## 스케줄링 메트릭

1. 성능 메트릭: 반환 시간(Turnaround time)

   - 작업이 완료된 시간에서 작업이 시스템에 도착한 시간을 뺀 값입니다.
   - 반환 시간 = 완료 시간 - 도착 시간

2. 공정성(Fairness)
   - 스케줄링에서 성능과 공정성은 종종 상충됩니다.

## 선입 선처리(FIFO) 또는 선착순(FCFS)

- 매우 간단하고 구현하기 쉽습니다.
- 예: A가 B보다 조금 먼저 도착하고, B는 C보다 조금 먼저 도착합니다. 각 작업은 10초 동안 실행됩니다.
- FIFO의 단점: 호위 효과(Convoy effect)
  - 가정 1 완화: 각 작업이 서로 다른 시간 동안 실행됩니다.
  - 예: A는 100초, B와 C는 각각 10초 동안 실행됩니다.

## 최단 작업 우선(SJF)

- 가장 짧은 작업을 먼저 실행하고, 그 다음으로 짧은 작업을 실행합니다.
- 비선점형 스케줄러입니다.
- 예: A는 100초, B와 C는 각각 10초 동안 실행됩니다.
- B와 C가 늦게 도착하는 SJF
  - 가정 2 완화: 작업은 언제든지 도착할 수 있습니다.
  - 예: A는 t=0에 도착하고 100초 동안 실행되어야 하며, B와 C는 t=10에 도착하고 각각 10초 동안 실행되어야 합니다.

## 최단 완료 시간 우선(STCF) 또는 선점형 최단 작업 우선(PSJF)

- SJF에 선점을 추가합니다.
- 새로운 작업이 시스템에 들어오면, 남은 작업과 새 작업 중 가장 적은 시간이 남은 작업을 스케줄링합니다.
- 예: A는 t=0에 도착하고 100초 동안 실행되어야 하며, B와 C는 t=10에 도착하고 각각 10초 동안 실행되어야 합니다.

## 새로운 스케줄링 메트릭: 응답 시간

- 작업이 도착한 시간부터 처음 스케줄링되는 시간까지의 시간입니다.
- STCF와 관련 기법들은 응답 시간에 그다지 좋지 않습니다.

## 라운드 로빈(RR) 스케줄링

- 시분할(Time slicing) 스케줄링입니다.
- 작업을 일정 시간(Time slice) 동안 실행한 후, 실행 대기열의 다음 작업으로 전환합니다. 이를 작업이 완료될 때까지 반복합니다.
- 시간 조각(Time slice)은 때로 스케줄링 단위(Quantum)라고도 합니다.
- 시간 조각의 길이는 타이머 인터럽트 주기의 배수여야 합니다.
- 예: A, B, C가 동시에 도착하고, 각각 5초 동안 실행되기를 원합니다.

## 시간 조각의 길이의 중요성

1. 짧은 시간 조각

   - 더 나은 응답 시간
   - 문맥 교환(Context switching) 비용이 전반적인 성능을 좌우합니다.

2. 긴 시간 조각
   - 전환 비용을 상쇄시킵니다.
   - 응답 시간이 나빠집니다.

## I/O 통합

- 가정 3 완화: 모든 프로그램이 I/O를 수행합니다.
- 예: A와 B는 각각 50ms의 CPU 시간이 필요합니다. A는 10ms 동안 실행된 후 I/O 요청을 하고, 각 I/O는 10ms가 걸립니다. B는 50ms 동안 CPU를 사용하고 I/O를 수행하지 않습니다.
- 작업이 I/O 요청을 시작하면, 해당 작업은 I/O 완료를 기다리며 차단(Blocked)됩니다. 이때 스케줄러는 CPU에서 다른 작업을 스케줄링해야 합니다.
- I/O가 완료되면 인터럽트가 발생하고, 운영체제는 프로세스를 차단 상태에서 준비(Ready) 상태로 이동시킵니다.
